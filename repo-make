#!/usr/bin/perl
#    repo-make - Tool to autobuild a set of PKGBUILD's into a working repository
#    Copyright (C) 2013 Manuel Reimer <manuel.reimer@gmx.de>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

# WARNING: This script is meant to be used on dedicated build hosts! The goal
# is to autobuild a bigger set of PKGBUILD's automatically without any
# confirmation. To make this possible, dependencies are automatically installed
# to the system, this script runs on!

use strict;
use warnings;
use Getopt::Std;
use Pod::PlainText;
use Cwd;
use File::Copy;
use File::Basename;
use POSIX;
use Term::ANSIColor;
use Archive::Tar;
use IPC::Open2;
use IPC::Open3;
use FileHandle;
use feature "state";
use constant {
  PW_NAME => 0,
  PW_UID  => 2,
  PW_GID  => 3,
  PW_DIR  => 7
};

my $VERSION = '1.0.0';
my $PROGNAME = 'repo-make';

# Main code
{
  # Colorize the error messages
  $SIG{__DIE__} =  sub {
    die(@_) if ($^S);
    print STDERR color('bold red'), "==> $PROGNAME ERROR: ", color('reset'),
                 color('bold'), $_[0], color('reset');
    exit(1);
  };

  # Read command line parameters
  my %opts;
  $Getopt::Std::STANDARD_HELP_VERSION = 1;
  getopts('Vt:', \%opts);

  # Check privileges. We have to be root!
  die("You have to be root to run repo-make!\n") if ($< != 0);

  # Check for package DB. If no update for over 24 hours, then force update!
  my $dbmtime = (stat('/var/lib/pacman/sync'))[9] or die();
  if (time() - $dbmtime > 24 * 60 * 60) {
    InfoMsg('Upgrading build system...');
    system('pacman', '-Syu', '--noconfirm');
  }

  # Read config file(s)
  my %cfg;
  ParseConfig('repo-make.conf', \%cfg, 1);
  die("Missing REPONAME in repomake.conf\n") unless defined($cfg{REPONAME});
  $cfg{TARGET} = "repo";
  ParseConfig('repo-make-custom.conf', \%cfg, 1)
    if (-s 'repo-make-custom.conf');
  $cfg{BUILDUSER} = "build";
  ParseConfig('/etc/repo-make.conf', \%cfg)
    if (-s '/etc/repo-make.conf');

  $cfg{TARGET} = $opts{t} if ($opts{t});

  # Check for BUILDUSER. If not there, create it.
  my @builduserinfo;
  unless (@builduserinfo = getpwnam($cfg{BUILDUSER})) {
    InfoMsg("Creating user '$cfg{BUILDUSER}'");
    system('useradd', '-m', $cfg{BUILDUSER});
    die("Failed to create user '$cfg{BUILDUSER}'\n") if ($?);
    @builduserinfo = getpwnam($cfg{BUILDUSER}) or die($!);
  }

  # Check if BUILDUSER is able to reach our stuff.
  system('su', $cfg{BUILDUSER}, '-c', 'cat repo-make.conf > /dev/null');
  die("User '$cfg{BUILDUSER}' is not allowed to access build data\n") if ($?);

  # Check for target directory. If missing, try to create it.
  unless (-d $cfg{TARGET}) {
    mkdir($cfg{TARGET}) or die("Failed to create directory '$cfg{TARGET}'\n");
  }

  # Read makepkg.conf
  my $makepkgconf = ReadMakepkgConf();

  # Get sure gpg-agent is running if we create signed packages
  HandleGPGAgent(\@builduserinfo) if ($makepkgconf->{BUILDENV}->{sign});

  # Read PKGBUILDs and preprocess header information
  my %pkgfilename;
  my @buildorder;
  foreach my $pkgbuildpath (@{$cfg{list}}) {
    next if ($pkgbuildpath =~ /(^#|^\s*$)/);
    die("Directory missing: $pkgbuildpath\n") unless (-d $pkgbuildpath);

    # Parse the PKGBUILD file
    my $pkgheader = ParsePKGBUILD($pkgbuildpath, $cfg{BUILDUSER});

    # Check for required header entries
    foreach my $tocheck ('pkgver', 'pkgrel') {
      die("Missing '$tocheck' in '$pkgbuildpath/PKGBUILD'\n")
        unless (defined($pkgheader->{$tocheck}));
    }
    foreach my $tocheck ('pkgname', 'arch') {
      die("Missing '$tocheck' in '$pkgbuildpath/PKGBUILD'\n")
        if (@{$pkgheader->{$tocheck}} == 0);
    }

    my $dependsref = [@{$pkgheader->{depends}},
                      @{$pkgheader->{makedepends}}];
    push(@$dependsref, @{$pkgheader->{checkdepends}})
      if ($makepkgconf->{BUILDENV}->{check});
    foreach my $pkgname (@{$pkgheader->{pkgname}}) {
      # Get expected package filename
      my $filename = "$pkgname-"
        . ($pkgheader->{epoch} ? "$pkgheader->{epoch}:" : '')
        . "$pkgheader->{pkgver}-$pkgheader->{pkgrel}-"
        . (($pkgheader->{arch}->[0] eq 'any') ? 'any' : $makepkgconf->{CARCH})
        . $makepkgconf->{PKGEXT};

      # Remember package filename and dependencies for later access
      $pkgfilename{$pkgname} = $filename;
      # Also store the same info for the provided packages
      foreach my $provided (@{$pkgheader->{provides}}) {
        $pkgfilename{$provided} = $filename;
      }
    }

    # Remember the data, we need for the build process
    push(@buildorder, [$pkgbuildpath, $pkgheader->{pkgname}, $dependsref]);
  }

  RemoveOrphanDeps() if ($opts{V});

  # Now run over all packages again and build missing packages
  PACKAGE: foreach my $packagedata (@buildorder) {
    my ($pkgbuildpath, $pkgnameref, $pkgdepends) = @$packagedata;

    # Still something to build?
    my $packages_built = 0;
    foreach my $pkgname (@$pkgnameref) {
      $packages_built++ if (-s "$cfg{TARGET}/$pkgfilename{$pkgname}");
    }
    next PACKAGE if ($packages_built == @$pkgnameref);

    # Get sure that package path is owned by our build user
    system ('chown', '-R', $cfg{BUILDUSER}, $pkgbuildpath);
    die("Failed to change owner of '$pkgbuildpath' to build user\n") if ($?);

    # Separate dependencies into "ours" and "system repository"
    my @repodeps;
    my @ourdeps;
    foreach my $depend (@$pkgdepends) {
      if (defined($pkgfilename{$depend})) {
        push(@ourdeps, $depend);
      }
      else {
        push(@repodeps, $depend);
      }
    }

    # Collect "dependencies of dependencies" for our packages
    my @depstocheck;
    my %depchecked;
    do {
      @depstocheck = @ourdeps;
      foreach my $depend (@depstocheck) {
        next if (defined($depchecked{$depend}));
        my $depdepends = GetPKGDeps("$cfg{TARGET}/$pkgfilename{$depend}");
        foreach my $depdepend (@$depdepends) {
          if (defined($pkgfilename{$depdepend})) {
            unshift(@ourdeps, $depdepend);
          }
        }
        $depchecked{$depend} = 1;
      }
    } while (@ourdeps != @depstocheck);

    # Get filenames for our dependencies
    $_ = $pkgfilename{$_} foreach (@ourdeps);

    # Get sure that we don't have duplicates in the list of our dependencies
    my %ourdeps_hash = map {$_ => 1} @ourdeps;
    @ourdeps = keys(%ourdeps_hash);

    # Install dependencies
    InfoMsg('Installing missing dependencies...') if (@ourdeps + @repodeps > 0);
    if (@ourdeps > 0) {
      my $oldcwd = getcwd();
      chdir($cfg{TARGET});
      AutoPacman('-U', '--needed', '--asdeps', @ourdeps)
        or die("pacman failed!\n");
      chdir($oldcwd);
    }
    if (@repodeps > 0) {
      AutoPacman('-S', '--needed', '--asdeps', @repodeps)
        or die("pacman failed!\n");
    }

    # Build package in context of BUILDUSER
    my $pid = fork();
    die('fork failed') unless(defined($pid));
    if ($pid == 0) {
      setgid($builduserinfo[PW_GID]) or die('setgid failed');
      setuid($builduserinfo[PW_UID]) or die('setuid failed');
      $ENV{HOME} = $builduserinfo[PW_DIR];
      chdir($pkgbuildpath);
      exec('makepkg', '-fc');
    }

    # Wait for the forked process, we created above, and check for build errors
    $SIG{INT} = 'IGNORE';
    $SIG{QUIT} = 'IGNORE';
    waitpid($pid, 0);
    $SIG{INT} = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    die("makepkg failed for '$pkgbuildpath'!\n") if ($?);

    # Check if all packages, we expected, have been created and move in place
    foreach my $pkgname (@$pkgnameref) {
      my $filename = $pkgfilename{$pkgname};
      die("Missing package: $filename\n") unless (-s "$pkgbuildpath/$filename");
      unlink("$cfg{TARGET}/$filename");
      move("$pkgbuildpath/$filename", $cfg{TARGET})
        or die("Move of '$filename' to '$cfg{TARGET}' failed: $!\n");

      if ($makepkgconf->{BUILDENV}->{sign}) {
        die("Signature missing!\n") unless (-s "$pkgbuildpath/$filename.sig");
        unlink("$cfg{TARGET}/$filename.sig");
        move("$pkgbuildpath/$filename.sig", $cfg{TARGET})
          or die ("Move of '$filename.sig' to '$cfg{TARGET}' failed: $!\n");
      }
    }

    RemoveOrphanDeps() if ($opts{V});
  }

  # Run cleanup on the target directory
  my %packages = reverse(%pkgfilename);
  opendir(my $DH, $cfg{TARGET}) or die();
  while (my $file = readdir($DH)) {
    next if ($file =~ /^\./);
    next if ($file !~ /\Q$makepkgconf->{PKGEXT}\E$/);
    unless (defined($packages{$file})) {
      unlink("$cfg{TARGET}/$file") or die("Failed to delete: $file\n");
      unlink("$cfg{TARGET}/$file.sig");
    }
  }
  closedir($DH);

  # Run cleanup on the DB file.
  my $dbpath = "$cfg{TARGET}/$cfg{REPONAME}.db.tar.gz";
  if (-s $dbpath) {
    my @dirstoremove;
    my %dirfiles;
    my $tar = Archive::Tar->new;
    my @files = $tar->read($dbpath);
    foreach my $tarfile (@files) {
      # Split dirname and filename part
      my ($dirname, $filename) = $tarfile->{name} =~ /([^\/]+)\/?(.*)/;

      # Store list of files in directory for the case, we want to delete it
      $dirfiles{$dirname} = [] unless($dirfiles{$dirname});
      push(@{$dirfiles{$dirname}}, $tarfile->{name});

      # Only continue for the file "desc" and try to find full package filename
      next if ($filename ne 'desc');
      my $pkgfilename = "$dirname-$makepkgconf->{CARCH}$makepkgconf->{PKGEXT}";
      unless ($packages{$pkgfilename}) {
        $pkgfilename = "$dirname-any$makepkgconf->{PKGEXT}";
      }

      # If the package file doesn't exist or is outdated, then remove from DB
      if (!$packages{$pkgfilename} ||
          (stat("$cfg{TARGET}/$pkgfilename"))[9] > $tarfile->{mtime}) {
        push(@dirstoremove, $dirname);
      }
      # If Package exists (and is up to date) then remove from list of packages
      elsif ($packages{$pkgfilename}) {
        delete($packages{$pkgfilename});
      }
    }

    # Process removals and write updated DB file
    if (@dirstoremove > 0) {
      foreach my $dirname (@dirstoremove) {
        $tar->remove(@{$dirfiles{$dirname}});
      }
      $tar->write($dbpath, COMPRESS_GZIP);
      my $shortdbpath = "$cfg{TARGET}/$cfg{REPONAME}.db";
      unlink($shortdbpath);
      symlink("$cfg{REPONAME}.db.tar.gz", $shortdbpath)
        or copy($dbpath, $shortdbpath) or die("Failed to write $shortdbpath\n");
    }
  }

  # Run "repo-add" if needed
  if (keys(%packages) > 0) {
    my $oldcwd = getcwd();
    chdir($cfg{TARGET});
    unlink("$cfg{REPONAME}.db");
    system('repo-add', "$cfg{REPONAME}.db.tar.gz", keys(%packages));
    die("repo-add failed\n") if ($?);
    chdir($oldcwd);
  }
}

sub VERSION_MESSAGE {
  print "$PROGNAME $VERSION\n";
}

sub HELP_MESSAGE {
  # Print out the built-in POD documentation in case of --help parameter
  Pod::PlainText->new(sentence => 0)->parse_from_file($0);
}

sub InfoMsg {
  print STDERR color('bold green'), "==> $PROGNAME: ", color('reset'),
               color('bold'), $_[0], color('reset'), "\n";
}

sub HandleGPGAgent {
  my ($aUserinfo) = @_;

  return unless (-x '/usr/bin/gpg-agent');

  # Make our builduser the owner of the tty, we run at.
  my $tty = readlink('/proc/self/fd/0');
  system('chown', $aUserinfo->[PW_NAME], $tty);
  die("Failed to chown '$tty' to build user\n") if ($?);

  # If info file exists, then read it and check connection. If OK, then return
  my $infofile = "$aUserinfo->[PW_DIR]/.gpg-agent-info";
  if (-f $infofile) {
    ReadGPGAgentInfo($infofile);
    system('su', $aUserinfo->[PW_NAME], '-c', 'gpg-agent 2> /dev/null');
    return unless ($?);
  }

  # Start daemon and read info file
  system('su', $aUserinfo->[PW_NAME], '-c',
         'gpg-agent --daemon --write-env-file > /dev/null');
  die("gpg-agent startup failed\n") if ($?);
  ReadGPGAgentInfo($infofile);
}

sub ReadGPGAgentInfo {
  my ($aPath) = @_;
  open(my $fh, '<', $aPath) or die("Failed to read '$aPath'\n");
  (my $info = <$fh>) =~ s/^[^=]+=//;
  close($fh);
  $ENV{GPG_AGENT_INFO} = $info;
}

sub RemoveOrphanDeps {
  open(my $fhlist, '-|', 'pacman', '-Qdtq') or die("Can't start pacman: $!\n");
  my $list = join('', <$fhlist>);
  close($fhlist);
  my @list = split("\n", $list);
  return if (@list == 0);
  InfoMsg('Uninstalling unrequired dependencies...');
  system('pacman', '-Rs', '--noconfirm', @list);
  die("pacman failed\n") if ($?);
}

sub GetPKGDeps {
  my ($aPath) = @_;

  die("Expected package '".basename($aPath)."' not built. Check build order!\n")
    unless (-s $aPath);

  state %cache;
  unless ($cache{$aPath}) {
    my @deplist;
    open(my $fhlist, '-|', 'bsdtar', '-xOf', $aPath, '.PKGINFO') or die();
    while(my $line = <$fhlist>) {
      my ($value) = $line =~ /^depend ?= ?(.+)$/ or next;
      # Drop anything after the equal sign
      $value =~ s/[<>=].*//;
      push(@deplist, $value);
    }
    $cache{$aPath} = \@deplist;
  }
  return $cache{$aPath};
}

# Subfunction to automate pacman in cases where "--noconfirm" doesn't work
sub AutoPacman {
  my @aOptions = @_;

  # Get sure that we have the same output everywhere
  local $ENV{LC_MESSAGES} = 'C';

  # Open pacman and connect our own STDIN and STDERR
  my($fhin, $fherr);
  use Symbol 'gensym'; $fherr = gensym;
  my $pid = open3($fhin, '>&STDOUT', $fherr, 'pacman', @aOptions);
  $fherr->autoflush(1);

  # Let's chat with pacman ;)
  while(sysread($fherr, my $buffer, 1024)) {
    print STDERR $buffer;
    # Remove conflicting packages, so we can go on with installation.
    if ($buffer =~ /are in conflict.*Remove/) {
      print STDERR "y\n";
      print $fhin "y\n";
    }
    # All other cases: Just proceed with default.
    elsif ($buffer =~ /Enter a number \(/ ||
           $buffer =~ /\[y\/n\]/i) {
      print STDERR "\n";
      print $fhin "\n";
    }
  }

  waitpid($pid, 0);
  return($? == 0);
}

sub ParseConfig {
  my($aPath, $aHashRef, $aListAllowed) = @_;
  my $mode = 0;

  my @list;
  open(my $FH, '<', $aPath) or die("Can't open '$aPath'\n");
  while (my $line = <$FH>) {
    $line =~ s/\s*$//;
    next if ($line =~ /^\s*#/ || $line eq '');

    if (my ($pref, $value) = $line =~ /^\s*([A-Z_]+)\s*=\s*(.+)/) {
      $aHashRef->{$pref} = $value;
    }
    elsif ($aListAllowed && $line =~ /^[A-Z0-9\/_.-]+$/i) {
      push(@list, $line);
    }
    else {
      die("Parsing error in '$aPath' on line $.\n");
    }
  }

  $aHashRef->{list} = \@list if (@list > 0);
}

# PKGBUILD parser
sub ParsePKGBUILD {
  my ($aPath, $aBuilduser) = @_;

  # List of variables, we need. The ones with "1" as value are arrays.
  my %variables = (pkgver  => 0, pkgrel      => 0, epoch        => 0,
                   pkgname => 1, provides    => 1, arch         => 1,
                   depends => 1, makedepends => 1, checkdepends => 1);

  # Open a bash instance in context of BUILDUSER.
  open2(my $fhout, my $fhin, 'su', $aBuilduser, '-s', '/usr/bin/bash');

  # Send small shellscript to load PKGBUILD and print out variables.
  print $fhin "cd '$aPath'\n";
  print $fhin "source PKGBUILD\n";
  print $fhin "IFS='\t'\n";
  print $fhin "echo \"$_\t\${$_\[*\]}\"\n" foreach (keys(%variables));
  close($fhin);

  # Interpret response.
  my %values;
  while(my $line = <$fhout>) {
    chomp($line);
    my($varname, @values) = split(/\t/, $line);
    # Drop anything after the equal sign
    s/[<>=].*// foreach(@values);
    $values{$varname} = ($variables{$varname} == 1) ? \@values : $values[0];
  }
  return \%values;
}

# makepkg.conf parser
sub ReadMakepkgConf {
  open(my $FH, '<', '/etc/makepkg.conf') or die("Can't read makepkg.conf\n");
  my %values;
  my $buildenv;
  while (my $line = <$FH>) {
    $values{CARCH} = $1 if ($line =~ /^CARCH=["']([^"']+)/);
    $values{PKGEXT} = $1 if ($line =~ /^PKGEXT=["']([^"']+)/);
    $buildenv = $1 if ($line =~ /^BUILDENV=\(([^)]+)/);
  }
  close($FH);

  die("Can't get CARCH from makepkg.conf\n") unless (defined($values{CARCH}));
  die("Can't get PKGEXT from makepkg.conf\n") unless (defined($values{PKGEXT}));
  die("Can't get BUILDENV from makepkg.conf\n") unless(defined($buildenv));
  $values{BUILDENV} = { map {$_ => 1} split(/\s+/, $buildenv) };

  return \%values;
}

__END__

=head1 NAME

repo-make - A tool to autobuild a set of PKGBUILD's

=head1 SYNOPSIS

B<repo-make>

=head1 DESCRIPTION

B<repo-make> is automatic build system, designed for distributions based on the pacman package manager and the PKGBUILD based (makepkg) build system.

It auto-generates packages based on a I<repo-make.conf> that has to exist in the the directory, where you call B<repo-make>.

=head2 Command Switches

Switches include:

=over 5

=item B<-t> <path>

Sets the target path where the finished packages are placed to and overrides the TARGET setting in repo-make.conf

=item B<-V>

Runs repo-make in "verify mode" which can be used to check if your I<depends> or I<makedepends> arrays really contain all needed packages for a successful build. To do this, repo-make uninstalls all orphan dependencies between the builds.

=item B<--help>

Display this help and exit

=item B<--version>

Output version information and exit

=back

=head1 WARNING

B<repo-make> has to run with root privileges as its goal is to auto-generate a set of packages B<without user interaction>! It will automatically update the system, repo-make runs on, and install missing dependencies from the global repositories or from the newly built packages.

Even though the build itself runs with an unprivileged user, it is not recommended to use repo-make on a productive system. Please set up a dedicated build environment. KVM or VirtualBox can be very handy to do so.

=head1 FILES

=over 5

=item F<./repo-make-custom.conf>

=item F<./repo-make.conf>

=item F</etc/repo-make.conf>

Configuration files that control the build process. Further information in repo-make.conf(5).

=back

=head1 SEE ALSO

repo-make.conf(5), makepkg.conf(5)
